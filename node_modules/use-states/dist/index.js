"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStates = exports.bindStateEffect = exports.bindState = void 0;
const react_1 = require("react");
function bindState(arrayOrGetter, setterOrPropName, propName) {
    if (setterOrPropName === undefined) {
        const [state, setState] = arrayOrGetter;
        return {
            value: state,
            onChange: (e) => setState(e.currentTarget.value),
        };
    }
    if (typeof setterOrPropName === 'string') {
        const [state, setState] = arrayOrGetter;
        return {
            [setterOrPropName]: state,
            onChange: (e) => setState(e.currentTarget[setterOrPropName]),
        };
    }
    if (propName === undefined) {
        return {
            value: arrayOrGetter,
            onChange: (e) => setterOrPropName(e.currentTarget.value),
        };
    }
    return {
        [propName]: arrayOrGetter,
        onChange: (e) => setterOrPropName(e.currentTarget[propName]),
    };
}
exports.bindState = bindState;
function bindStateEffect(arrayOrGetter, setterOrFieldName, fieldNameOrCallback, callback) {
    if (fieldNameOrCallback === undefined && typeof setterOrFieldName === 'function') {
        const [state, setState] = arrayOrGetter;
        return {
            value: state,
            onChange: (e) => {
                setState(e.currentTarget.value);
                setterOrFieldName(e.currentTarget.value);
            },
        };
    }
    if (callback === undefined
        && typeof setterOrFieldName === 'string'
        && typeof fieldNameOrCallback === 'function') {
        const [state, setState] = arrayOrGetter;
        return {
            [setterOrFieldName]: state,
            onChange: (e) => {
                setState(e.currentTarget[setterOrFieldName]);
                fieldNameOrCallback(e.currentTarget[setterOrFieldName]);
            },
        };
    }
    if (callback === undefined
        && typeof setterOrFieldName === 'function'
        && typeof fieldNameOrCallback === 'function') {
        return {
            value: arrayOrGetter,
            onChange: (e) => {
                setterOrFieldName(e.currentTarget.value);
                fieldNameOrCallback(e.currentTarget.value);
            },
        };
    }
    if (typeof setterOrFieldName === 'function'
        && typeof fieldNameOrCallback === 'string'
        && typeof callback === 'function') {
        return {
            [fieldNameOrCallback]: arrayOrGetter,
            onChange: (e) => {
                setterOrFieldName(e.currentTarget[fieldNameOrCallback]);
                callback(e.currentTarget[fieldNameOrCallback]);
            },
        };
    }
    return {
        value: undefined,
        onChange: undefined,
    };
}
exports.bindStateEffect = bindStateEffect;
/**
 * Makes every property in an object of initial values to be stateful
 * @param initialValues An object of initial values
 * @returns An object with the same properties but the properties are all stateful
 */
function useStates(initialValues) {
    const data = {};
    Object.entries(initialValues).forEach(([key, value]) => {
        const [state, setState] = react_1.useState.call(this, value);
        const stateContainer = react_1.useRef(null);
        stateContainer.current = state;
        data[key] = [stateContainer, (val) => {
                setState(val);
                stateContainer.current = val;
            }];
    });
    const proxy = new Proxy(data, {
        get(target, name, receiver) {
            if (typeof name === 'symbol') {
                return Reflect.get(target, name, receiver);
            }
            if (name === '__isProxy') {
                return true;
            }
            if (name.startsWith('$')) {
                const key = name.substr(1);
                return [target[key][0].current, target[key][1]];
            }
            return target[name][0].current;
        },
        set(target, name, value, receiver) {
            if (typeof name === 'symbol') {
                return Reflect.set(target, name, value, receiver);
            }
            if (name.startsWith('$')) {
                if (!(value instanceof Array))
                    return false;
                if (value.length < 2)
                    return false;
                const key = name.substr(1);
                target[key] = value;
                return true;
            }
            target[name][1](value);
            return true;
        },
    });
    return proxy;
}
exports.useStates = useStates;
